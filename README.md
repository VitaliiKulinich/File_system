# Системне програмне забезпечення
Файлова система (частина 1)

У даній лабораторній роботі необхідно розробити драйвер файлової системи для носія інформації блокового типу і частину підсистеми ядра ОС, що підтримує файлові системи. В носії інформації блокового типу введення-виведення відбувається блоками, кожний блок має один і той же розмір (один або кілька блоків за одне звернення до пристрою), розмір блоку визначається апаратурою. Зазвичай в таких пристроях не враховуються обмеження на кількість змін в одному блоці.

У ФС є два типи файлів: звичайні файли (regular) і директорії (direcotory). У цій лабораторній роботі необхідно реалізувати однорівневу ФС з однією директорією, що “містить” звичайні файли.

Вміст кожного файлу зберігається в блоках, один блок містить інформацію тільки одного файлу. Для обліку зайнятості блоків необхідно застосувати бітову мапу, один біт визначає чи є відповідний блок зайнятий. Так як кількість блоків в пристрої стала, то бітова мапа буде містити постійну кількість бітів. У деяких файлів останній блок буде використовуватися в неповному обсязі під дані файлу. Блоки в структурах ФС адресуються по їх порядковими номерами.

Кожен файл, як об’єкт ФС, представлений дескриптором. Кількість дескрипторів заздалегідь задається, тому в ФС не може бути створено більше певної кількості файлів, навіть якщо в пристрої є вільне місце. Дескриптор файлу повинен містити, принаймні, таку інформацію: тип файлу (звичайний файл або директорія), кількість посилань на файл, розмір файлу у байтах, мапу розташування блоків файлу. Мапа розташування блоків має наступну структуру: є кілька прямих посилань на блоки та є одне посилання на один блок, що містить прямі посилання на блоки. Номер (позиція) посилання визначає зміщення даних у файлі, посилання нумеруються підряд. Посилання не вказує на блок в двох випадках: відповідне зміщення перевищує розмір файлу або всі байти файлу відповідного блоку файлу дорівнюють нулю. Звичайні файли використовуються користувачем для зберігання інформації і для ФС не мають форматів.

Директорія це файл, дані якого це масив посилань (link) на файли та відповідних номерів дескрипторів файлів. Формат даних директорії задається форматом ФС і не інтерпретується користувачем. Посилання на файл це ім’я файлу. Так як ім’я файлу не є частиною дескриптора файлу, то на один файл може бути кілька посилань, тобто один файл може мати кілька імен. Так як посилання на файли можуть бути знищені, то необхідно передбачити можливість позначати недійсні посилання на файли в директорії. Ім’я файлу це набір символів, довжина імені файлу обмежена форматом ФС.

У цій лабораторній роботі не потрібно організовувати буферний кеш і кеш імен файлів. Драйвер ФС при будь-якому запиті повинен працювати безпосередньо з даними на носії інформації.

Завдання на роботу:

Розробити драйвер ФС і частину підсистеми ядра ОС, що підтримує файлові системи, що відповідає наведеній вище семантиці ФС. Драйвер ФС і частину ядра ОС реалізувати у програмі користувача. Для дескриптору файлу використати наведену вище ідею структури дескриптора. В якості носія інформації взяти звичайний файл в наявній ФС, розмір файлу визначає розмір носія інформації. Самостійно вибрати розмір блоку, кількість посилань на блоки в дескрипторі файлу, максимальну довжину імені файлу. Розроблена програма не має бути ФС типу bypass чи pass through, всі дії щодо ФС мають відбуватися в розробленій програмі. Використовувати FUSE чи схожу систему не можна, тому що в лабораторній роботі треба реалізувати частину підсистеми ядра ОС, якщо використовувати FUSE, то буде використовуватися наявна підсистема ядра. 

Замість використання звичайного файлу в наявній ФС в якості носія інформації, можна використати пам’ять як носій інформації. Тобто розробити драйвер ФС для пам’яті. В такому випадку замість бітової мапи, можна використати більш оптимальну структуру, для представлення вмісту директорії також можна використати щось більш оптимальніше ніж блоки. Звичайні файли все одно мають складатися з блоків.

Розробити консольну програму, яка підтримує наступні команди (замість консольної програми можна в тестах викликати набір відповідних функцій):

mkfs n – відформатувати ФС, n це кількість файлових дескрипторів;
mount  – під’єднати ФС з носія інформації;
umount – від’єднати ФС, в драйвері і ядрі не повинно залишитися жодних даних про ФС;
fstat id – вивести інформацію з дескриптору файлу з вказаним номером id;
ls – вивести список посилань на файли із зазначенням номерів дескрипторів файлів;
create name – створити звичайний файл і створити на нього посилання name;
open name – відкрити файл, на який вказує посилання name. Команда повинна призначити унікальний номер fd (назвемо цей номер “числовий файловий дескриптор”) для роботи з відкритим файлом (це число це не те саме, що номер дескриптору, що визначає файл у ФС). Один файл може бути відкритий кілька разів;
close fd – закрити раніше відкритий файл з числовим файловим дескриптором fd, унікальний номер fd більше не повинен бути пов’язаний з файлом;
read fd offset size – прочитати дані з відкритого файлу з числовим файловим дескриптором fd за заданим зміщення offset зазначеного розміру size байт;
write fd offset size – записати дані у відкритий файл з числовим файловим дескриптором fd за заданим зміщення offset зазначеного розміру size байт; 
link name1 name2 – створити посилання name2 на наявний файл, на який вказує посилання name1;
unlink name – знищити посилання name;
truncate name size – змінити розмір файлу, на який вказує посилання name. Якщо розмір файлу збільшується, то неініціалізовані дані дорівнюють нулю.

Драйвер ФС звільнює дані файлу, якщо на файл нема жодного посилання і файл не є відкритим. Файл може не мати жодного посилання, при цьому він може бути відкритий і з ним можна виконувати команди read та write.

Якщо truncate збільшує розмір файлу, то використати оптимізацію і не створювати блоки, вміст яких складається з нулів. 



Література:

Таненбаум “Современные операционные системы”, 4-е издание.
